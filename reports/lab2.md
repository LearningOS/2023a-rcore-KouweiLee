# lab2-李国玮

## 编程作业

首先对于lab1的两个函数，难点在于当数据对象横跨一页时的情况。我通过`translated_byte_buffer`函数获得TimeVal和TaskInfo的字节切片形式，然后将数据按u8复制进去，具体实现可见`copy_kernel_data`函数。

mmap只需要构造MapArea然后通过insert_framed_area将其插入到进程的地址空间即可。难点主要在于错误处理。

munmap则较为简单，找到对应的area并从地址空间中移除即可。

## 问答作业

### 1

![../_images/sv39-pte.png](https://learningos.cn/rCore-Tutorial-Guide-2023A/_images/sv39-pte.png)

63-54位：保留

53-10位：物理页号，分为3级页表

9-8位：RSW，Reserved for Software。 用于预留给软件做自定义页表功能的位。

D：dirty，表示该页表项对应的虚拟页表时候被修改过

A：access，虚拟页面是否被访问过

G：global，如果为1,则所有页表都包含这一项

U：该页表项对应的虚拟页面是否允许U特权级访问

RWX：该虚拟页面是否允许读、写、可执行

V：valid，只有为1时才合法。

### 2

* 哪些异常可能是缺页导致的？

要访问的虚拟地址尚未建立地址映射关系

要访问的虚拟页面对应的物理页面已经swap到磁盘上，内存中不存在

用户态下访问内核态地址。

* 发生缺页时，描述相关重要寄存器的值，上次实验描述过的可以简略

stval：记录产生缺页的虚拟地址

sepc：记录产生缺页的指令地址

- 处理 10G 连续的内存页面，对应的 SV39 页表大致占用多少内存 (估算数量级即可)？

SV39页表采用3级页表，每张页表为4KB，页表项64位即8B，故一个三级页表管理512*4=2MB内存，一个二级页表管理2MB\*512=1GB内存。故需要一个根页表和10个二级页表，以及5120个三级页表。共占内存约20MB。

- 请简单思考如何才能实现 Lazy 策略，缺页时又如何处理？描述合理即可，不需要考虑实现。

为页表项增加一个标志位，表示该页面是否在磁盘里。如果访问一个虚拟地址，发现对应的页面在磁盘中，则产生缺页异常并跳入一个异常处理函数，该函数会将磁盘中的页面调入内存并为页表增加地址映射关系。之后异常返回到访问这个虚拟地址的指令，该指令再次执行时就会访问到内存的数据了。

* 页面失效如何体现在页表项

增加一个标志位，表示该页面是否在磁盘里。

### 3

- 在单页表情况下，如何更换页表？

在内核启动过程中，使能MMU后，内核需要首先建立一套页表a，维护内核的地址映射。当启动进程后，每个进程会拥有一个根页表b，且对于内核态所在的虚拟地址范围，其根页表会指向a中相同地址的所有二级页表。之后a的根页表就不再使用，当任务切换时，只需要切换进程的页表；而发生异常时，则不需要切换页表。

- 单页表情况下，如何控制用户态无法访问内核页面？（tips:看看上一题最后一问）

其实有2种方案，一种是在页表项中增加标志位，是否允许用户态读取。所有的内核页面对应的页表项都应该将该标志位置为不允许用户态读取。第二种方案是，由CPU硬件实现，对哪段虚拟地址只允许内核态访问，哪些属于用户态。

- 单页表有何优势？（回答合理即可）

实现起来简单，发生异常时不需要跳板页面

* 双页表实现下，何时需要更换页表？假设你写一个单页表操作系统，你会选择何时更换页表（回答合理即可）？

双页表下，发生异常和返回异常时都需要更换页表

而单页表则只需要在任务切换时更换页表即可。

## 荣誉准则

1. 在完成本次实验的过程（含此前学习的过程）中，我曾分别与 **无人** 就（与本次实验相关的）以下方面做过交流，还在代码中对应的位置以注释形式记录了具体的交流对象及内容。
2. 此外，我也参考了 **无其他资料** ，还在代码中对应的位置以注释形式记录了具体的参考来源及内容
3. 我独立完成了本次实验除以上方面之外的所有工作，包括代码与文档。 我清楚地知道，从以上方面获得的信息在一定程度上降低了实验难度，可能会影响起评分。
4. 我从未使用过他人的代码，不管是原封不动地复制，还是经过了某些等价转换。 我未曾也不会向他人（含此后各届同学）复制或公开我的实验代码，我有义务妥善保管好它们。 我提交至本实验的评测系统的代码，均无意于破坏或妨碍任何计算机系统的正常运转。 我清楚地知道，以上情况均为本课程纪律所禁止，若违反，对应的实验成绩将按“-100”分计。